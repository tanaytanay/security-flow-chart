<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
    }

    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 30px;
    }

    .mermaid {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background-color: #f8f9fa;
      border-radius: 8px;
    }

    .controls {
      text-align: center;
      margin: 20px 0;
    }

    .btn {
      color: white;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      user-select: none;
      transition: background-color 0.3s ease;
    }

    .btn-red {
      background-color: #e74c3c;
    }

    .btn-red:hover {
      background-color: #c0392b;
    }

    .btn-orange {
      background-color: #e67e22;
    }

    .btn-orange:hover {
      background-color: #d35400;
    }

    .btn-purple {
      background-color: #9b59b6;
    }

    .btn-purple:hover {
      background-color: #8e44ad;
    }

    .btn-reset {
      background-color: #3498db;
    }

    .btn-reset:hover {
      background-color: #2980b9;
    }
  </style>
</head>

<body>
  <div class="container">

    <div class="controls">
      <button class="btn btn-red"
        onclick="renderMermaid({ circle: 'ingress', agentName: 'Agent 1', llmName: 'Claude', color: '#e74c3c' })">1</button>
      <button class="btn btn-orange"
        onclick="renderMermaid({ circle: 'ingress', agentName: 'Agent 2', llmName: 'Gemini', color: '#e67e22' })">2</button>
      <button class="btn btn-purple"
        onclick="renderMermaid({ circle: 'egress', agentName: 'Agent 3', llmName: 'OpenAI', color: '#9b59b6' })">3</button>
      <button class="btn btn-reset" onclick="resetToDefault()">None</button>
    </div>

    <div class="mermaid" id="chart"></div>
  </div>

  <script>
    // Reset page
    function resetToDefault() {
      location.reload();
    }

    // Mermaid config
    mermaid.initialize({
      startOnLoad: false,
      theme: 'default',
      flowchart: {
        useMaxWidth: true,
        htmlLabels: true,
        curve: 'basis',
        nodeSpacing: 20,
        rankSpacing: 200,
      }
    });

    function hexToRgb(hex) {
      // Remove leading "#" if present
      hex = hex.replace(/^#/, '');

      // Handle shorthand hex (#fff)
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }

      // Parse the hex values
      const bigint = parseInt(hex, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;

      return `rgb(${r}, ${g}, ${b})`;
    }

    // Generate Mermaid diagram source with path marking and custom colors
    function generateMermaidWithMarkedPath(data, mark) {
      const lines = ["graph LR"];

      const nodeClasses = {};
      const edges = [];

      const attackerId = "A";
      const vmId = "B";

      // Default VM circle colors (transparent by default)
      const ingressDefault = "transparent";
      const egressDefault = "transparent";

      // Use custom color if given, else fallback to blue
      const highlightColor = mark && mark.color ? mark.color : ingressDefault;

      // Build VM label with circles colored appropriately
      let ingressBg = ingressDefault;
      let egressBg = egressDefault;
      let ingressBorder = '#3498db';
      let egressBorder = '#3498db';

      if (mark && mark.circle === "ingress") {
        ingressBg = highlightColor;
        ingressBorder = highlightColor;
      } else if (mark && mark.circle === "egress") {
        egressBg = highlightColor;
        egressBorder = highlightColor;
      }

      ingressBorder = hexToRgb(ingressBorder);
      egressBorder = hexToRgb(egressBorder);

      console.log("ingressBorder:", ingressBorder, typeof ingressBorder);
      console.log("egressBorder:", egressBorder, typeof egressBorder);

      let vmLabel = `<div style='text-align: center;'>
        <strong>${data.vm.name}</strong><br/>
        <div style='display: flex; flex-direction: column; align-items: center; gap: 10px;'>
          <div id='ingress-circle' style='width: 60px; height: 60px; border-radius: 50%; background: transparent; border: 1px solid ${ingressBorder}; display: flex; align-items: center; justify-content: center;'><img src='icons/aif_ingress.png' width='72' height='72' style='object-fit: contain;'/></div>
          <div id='egress-circle' style='width: 60px; height: 60px; border-radius: 50%; background: transparent; border: 1px solid ${egressBorder}; display: flex; align-items: center; justify-content: center;'><img src='icons/aif_egress.png' width='72' height='72' style='object-fit: contain;'/></div>
        </div>
      </div>`;

      nodeClasses[attackerId] = "node-unmarked";
      nodeClasses[vmId] = "node-unmarked";

      data.agents.forEach((agent, ai) => {
        const agentId = `C${ai + 1}`;
        nodeClasses[agentId] = "node-unmarked";

        edges.push([vmId, agentId]);
        lines.push(`B --> ${agentId}((${agent.name}))`);

        agent.llms.forEach((llm, li) => {
          const llmId = `D${ai + 1}_${li + 1}`;
          nodeClasses[llmId] = "node-unmarked";

          edges.push([agentId, llmId]);
          lines.push(`${agentId} --> ${llmId}((<img src="${llm.icon}" width="72" height="72" style="display: block; margin: 0 auto; object-fit: contain;"/>))`);
        });
      });

      // Find IDs for marked nodes
      let markedAgentId = null;
      let markedLlmId = null;
      data.agents.forEach((agent, ai) => {
        if (mark && agent.name === mark.agentName) {
          markedAgentId = `C${ai + 1}`;
          agent.llms.forEach((llm, li) => {
            if (mark && llm.name === mark.llmName) {
              markedLlmId = `D${ai + 1}_${li + 1}`;
            }
          });
        }
      });

      // Validate marking
      const isValidMark = mark &&
        (mark.circle === "ingress" || mark.circle === "egress") &&
        markedAgentId &&
        markedLlmId;

      if (isValidMark) {
        nodeClasses[attackerId] = "node-marked";
        nodeClasses[markedAgentId] = "node-marked";
        nodeClasses[markedLlmId] = "node-marked";
      }

      // Add attacker -> vm edge with label as VM div
      lines.push(`A((<img src="icons/attackers.png" width="48" height="48" style="display: block; object-fit: contain;"/>)) --> B["${vmLabel}"]`);
      edges.push([attackerId, vmId]);

      // Mark edges on the highlighted path
      const markedEdgesIndexes = [];
      edges.forEach(([src, dst], i) => {
        if (isValidMark && (
          (src === attackerId && dst === vmId) ||
          (src === vmId && dst === markedAgentId) ||
          (src === markedAgentId && dst === markedLlmId)
        )) {
          markedEdgesIndexes.push(i);
        }
      });

      lines.push("");
      lines.push(`classDef node-marked fill:transparent,color:#000,stroke:${highlightColor};`);
      lines.push("classDef node-unmarked fill:transparent,color:#000,stroke:#3498db;");
      lines.push("classDef vm-node fill:transparent,color:#000,stroke:#a8a8a8;");
      lines.push(`classDef edge-marked stroke:${highlightColor},stroke-width:3px;`);
      lines.push("classDef edge-unmarked stroke:#000,stroke-width:1px;");

      // Always gray VM node
      lines.push(`class B vm-node;`);

      Object.entries(nodeClasses).forEach(([nodeId, cls]) => {
        if (nodeId !== 'B') { // Skip VM node (B)
          lines.push(`class ${nodeId} ${cls};`);
        }
      });

      edges.forEach(([src, dst], i) => {
        if (markedEdgesIndexes.includes(i)) {
          lines.push(`linkStyle ${i} stroke:${highlightColor},stroke-width:3px;`);
        } else {
          lines.push(`linkStyle ${i} stroke:#000,stroke-width:1px;`);
        }
      });

      return lines.join("\n");
    }

    // Your data
    const securityFlowData = {
      attacker: "Attacker",
      vm: { name: "VM", ingress: "ingress", egress: "egress" },
      agents: [
        { name: "Agent 1", llms: [{ name: "Gemini", icon: "icons/gemini.png" }, { name: "Claude", icon: "icons/claude.png" }] },
        { name: "Agent 2", llms: [{ name: "Gemini", icon: "icons/gemini.png" }] },
        { name: "Agent 3", llms: [{ name: "Claude", icon: "icons/claude.png" }, { name: "OpenAI", icon: "icons/openai.png" }, { name: "Gemini", icon: "icons/gemini.png" }] },
      ]
    };

    // Render Mermaid diagram
    async function renderMermaid(mark = null) {
      const chartDiv = document.getElementById("chart");
      let mermaidSource;

      if (mark) {
        mermaidSource = generateMermaidWithMarkedPath(securityFlowData, mark);
      } else {
        mermaidSource = generateMermaidWithMarkedPath(securityFlowData, {
          circle: null,
          agentName: null,
          llmName: null,
          color: null
        });
      }

      try {
        const { svg } = await mermaid.render('theGraph', mermaidSource);
        chartDiv.innerHTML = svg;
      } catch (e) {
        chartDiv.textContent = 'Error rendering Mermaid diagram: ' + e.message;
        console.error(e);
      }
    }

    // On page load, render default with no path highlight
    document.addEventListener("DOMContentLoaded", () => {
      renderMermaid(null);
    });
  </script>
</body>

</html>